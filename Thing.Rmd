---
title: "Final_Project"
output: pdf_document
date: "2025-06-03"
---
## Identify an

```{r}
library(dplyr)
# load in the data
chess_matrix <- scan("chess/out.chess", 
                    skip = 1,  # skip header line
                    what = numeric(), 
                    quiet = TRUE)

chess_data <- matrix(chess_matrix, ncol = 4, byrow = TRUE)
chess_data <- as.data.frame(chess_data)
colnames(chess_data) <- c("player1", "player2", "outcome", "timestamp")
# Add column names

# If outcome is -1 set it to 2
chess_data$outcome[chess_data$outcome == -1] <- 2

# convert unix timestamp to POSIXct
chess_data$timestamp <- as.POSIXct(chess_data$timestamp, origin = "1970-01-01", tz = "UTC")
chess_data$timestamp <- format(chess_data$timestamp, "%m-%Y")

# Check the data
tail(chess_data)
str(chess_data)
dim(chess_data)

# Summary statistics
summary(chess_data)
```

```{r}
# Create a network where edges represent games played
# (ignoring outcomes for now)
library(igraph)

chess_net <- graph_from_data_frame(chess_data[,1:2], directed = FALSE)


# Basic network info
```


## Outcome-based Network 

```{r}
library(dplyr)
library(igraph)

chess_edges <- chess_data %>%
  transmute(
    white = player1,        
    black = player2,        
    outcome = outcome,       
    timestamp = timestamp
  )

chess_edges$outcome[chess_edges$outcome == -1] <- 2

chess_net <- graph_from_data_frame(
  chess_edges,
  directed = TRUE,
  vertices = NULL 
)

E(chess_net)$outcome <- chess_edges$outcome
E(chess_net)$timestamp <- chess_edges$timestamp

E(chess_net)$color <- ifelse(
  E(chess_net)$outcome == 1,  "blue",
    ifelse(E(chess_net)$outcome == 0, "gray", "red")
)
```




```{r}
set.seed(42)


subset_size <- length(V(chess_net))
subset_vertices <- sample(V(chess_net), subset_size)
chess_net_subset <- induced_subgraph(chess_net, subset_vertices)


```

```{r}
# Basic network statistics
network_stats <- data.frame(
  Measure = c(
    "Nodes", 
    "Edges", 
    "Density", 
    "Transitivity", 
    "Average Path Length",
    "Diameter", 
    "Reciprocity"
  ),
  Value = c(
    vcount(chess_net),           # Number of nodes
    ecount(chess_net),            # Number of edges
    edge_density(chess_net),      # Network density
    transitivity(chess_net),      # Clustering coefficient
    mean_distance(chess_net), # Average path length
    diameter(chess_net),          # Network diameter
    reciprocity(chess_net)        # Reciprocity (for directed network)
  )
)

# Node-level measures
node_measures <- data.frame(
  Node = V(chess_net)$name,       # Player IDs
  Degree = degree(chess_net),     # Total connections
  In_Degree = degree(chess_net, mode = "in"),   # Incoming connections
  Out_Degree = degree(chess_net, mode = "out"), # Outgoing connections
  Betweenness = betweenness(chess_net),
  Closeness = closeness(chess_net),
  Eigenvector = eigen_centrality(chess_net)$vector
)

# Optional: Sort by degree to see most connected players
head(node_measures[order(node_measures$Degree, decreasing = TRUE), ])
```
```{r}
# get the degree for each playerID in the thingy 
library(igraph)
layout_fr <- layout_with_fr(chess_net, niter = 1000)  


```

```{r}
all_degrees <- igraph::degree(chess_net)

# Get the top 100 players by degree
top_100_ids <- names(sort(all_degrees, decreasing = TRUE)[1:100])

# Create subset with just these top 100 players
chess_top100 <- induced_subgraph(chess_net, top_100_ids)

```





```{r}
library(igraph)

# If your graph is large, select a random subset of nodes:
chess_subset <- chess_top100

# Calculate node attributes for the SUBSET
node_degree <- igraph::degree(chess_subset)
node_activity <- log1p(node_degree)  # Log transform for better scaling

# Color edges by outcome
E(chess_subset)$color <- case_when(
  E(chess_subset)$outcome == 1 ~ "#2E8B57",   # Green for white wins
  E(chess_subset)$outcome == 0 ~ "#808080",   # Gray for draws  
  E(chess_subset)$outcome == 2 ~ "#DC143C",   # Red for black wins
  TRUE ~ "#000000"                             # Black for unknown
)

# Calculate win ratio for node colors
in_degree <- igraph::degree(chess_subset, mode = "in")
out_degree <- igraph::degree(chess_subset, mode = "out")
win_ratio <- out_degree / (in_degree + out_degree + 0.01)  # Avoid division by 0

# Color nodes by performance
node_colors <- colorRampPalette(c("#4169E1", "#FFFFFF", "#FF6347"))(100)
node_color_indices <- pmax(1, pmin(100, round(win_ratio * 100)))
V(chess_subset)$color <- node_colors[node_color_indices]

# Generate layout for the SUBSET
layout_fr <- layout_with_fr(chess_subset, niter = 1000)

# Create the plot with improved aesthetics
par(mar = c(1, 1, 3, 1), bg = "white")
plot(
  chess_subset,
  layout = layout_fr,
  
  # Vertex (node) styling
  vertex.size = pmax(3, pmin(12, node_activity * 2)),  # Size by activity
  vertex.color = V(chess_subset)$color,
  vertex.frame.color = "darkgray",
  vertex.frame.width = 0.5,
  vertex.label = NA,
  
  # Edge styling  
  edge.color = paste0(E(chess_subset)$color, "99"),  # Add transparency
  edge.arrow.size = 0.4,
  edge.arrow.width = 0.8,
  edge.curved = 0.1,  # Slight curve to reduce overlap
  
  # Overall plot
  main = "Chess Network: White Wins (Green), Draws (Gray), Black Wins (Red)",
  sub = "Node size = activity level, Node color = win ratio (blue=poor, red=good)"
)

```

```{r}
# Choose your player of interest, for example:
player_id <- 1  # replace with the actual ID you want to inspect

# Find the ego-network: all nodes connected to this player (order = 1)
ego_net <- make_ego_graph(chess_net, order = 1, nodes = as.character(player_id), mode = "all")[[1]]

# Nice layout
layout_ego <- layout_with_fr(ego_net)

# Highlight your ego node (the center player)
V(ego_net)$color <- ifelse(V(ego_net)$name == as.character(player_id), "gold", "lightblue")
V(ego_net)$size <- ifelse(V(ego_net)$name == as.character(player_id), 15, 8)

plot(
  ego_net, 
  layout = layout_ego,
  vertex.label = V(ego_net)$name,
  vertex.label.cex = 0.8,
  vertex.label.color = "black",
  vertex.size = V(ego_net)$size,
  vertex.color = V(ego_net)$color,
  edge.arrow.size = 0.4,
  edge.curve = 0.1, 
  main = paste("Connections for Player", player_id)
)
```

# Question 1: Do we see Reciprocity and Transitivity that is greater than chance? 


```{r}
library(statnet)         # loads network, ergm, sna, etc.
library(ergm)
library(dplyr)

# Aggregate multiple games between same players
chess_edges <- chess_data %>%
  group_by(player1, player2) %>%
  summarise(
    total_games = n(),
    wins_p1 = sum(outcome == 1),
    draws = sum(outcome == 0), 
    wins_p2 = sum(outcome == 2),
    .groups = 'drop'
  ) %>%
  select(player1, player2, total_games)  # Keep edge weights

# Convert to network object 
chess_network <- network(as.matrix(chess_edges[,1:2]), directed = FALSE)

# Add edge weight attribute
set.edge.attribute(chess_network, "weight", chess_edges$total_games)

# Fit ERGM
model1 <- ergm(chess_network ~ edges + triangles + degree(2),
               estimate = "MPLE")

summary(model1)

```
As the edge coefficient is negative at -6.58, this indicates that there is a strong negative tendency to form connections. The network is indeed very sparse, as shown by the density, so this makes sense. 

For the triangle coefficient, there is a strong positive transitivity effect of 0.46 which is also statistically significant. This indicates that if player A plays with player B, then player C is more likely to play with both A and B. 

The degree value of -0.10 also indicates that players tend to not have exactly 2 players. Hence, this shows that players tend to be active, and are clustered. This suggests a community based structure. 

However in order to evaluate the reciprocity, we redefine the network as directed, where player1 is always white and player2 is always black.

```{r}
# detach igraph
detach("package:igraph", unload = TRUE)
# Create directed edge list preserving white->black direction
chess_edges_directed <- chess_data %>%
  # Keep the original direction (player1 = white, player2 = black)
  group_by(player1, player2) %>%
  summarise(
    total_games = n(),
    wins_white = sum(outcome == 1),
    draws = sum(outcome == 0),
    wins_black = sum(outcome == 2),
    .groups = 'drop'
  ) %>%
  select(player1, player2, total_games, wins_white, draws, wins_black)

# Create DIRECTED network
chess_network_directed <- network(as.matrix(chess_edges_directed[,1:2]), directed = TRUE)

# Add edge attributes
set.edge.attribute(chess_network_directed, "total_games", chess_edges_directed$total_games)
set.edge.attribute(chess_network_directed, "wins_white", chess_edges_directed$wins_white)
set.edge.attribute(chess_network_directed, "draws", chess_edges_directed$draws)
set.edge.attribute(chess_network_directed, "wins_black", chess_edges_directed$wins_black)


# Now test reciprocity
model_reciprocity <- ergm(chess_network_directed ~ edges + triangles  + mutual, estimate = "MPLE")

summary(model_reciprocity)



```



## New model with reciprocity

When accounting for reciprocity, we see that the mutual coefficient is +2.45. This indicates that if player A were to play white against player B there is a strong tendency for player B to play white against player A.

This is a strong positive effect, and indicates that players tend to play with each other in both directions.  

The triangle coefficient in this case is 0.20 which is still positive, but much lower than the previous model. This indicates that the transitivity effect is still present, but not as strong as before.

However, in this case the edge coefficient is -7.09 which indicates more sparsity. This makes sense as we are now considering specific colors that are being played by the players. 


## Question 2: Are players with similar win ratios more likely to be connected using ERMG? 

First we have to calculate the win ratios for each player. The direction of the edges indicates whether the player played white or black. The value of the edge indicates whether the player won or lost. Accordingly we have: 

```{r}
# Step 1: Calculate actual win ratios for all players
library(igraph)

white_wins <- E(chess_net)[outcome == 1] # White player won
black_wins <- E(chess_net)[outcome == 2] # Black player won

player_ids <- as.character(V(chess_net))
wins <- rep(0, length(player_ids))
names(wins) <- player_ids
games_played <- rep(0, length(player_ids))
names(games_played) <- player_ids


# Count games played by each player (both as white and black)
for (e in E(chess_net)) {
  src <- as.character(ends(chess_net, e)[1])
  dst <- as.character(ends(chess_net, e)[2])
  
  # Increment games played for both players
  games_played[src] <- games_played[src] + 1  # White player
  games_played[dst] <- games_played[dst] + 1  # Black player
}

# if the number ends in 1, it's a win for white
for (e in white_wins) {
  src <- as.character(ends(chess_net, e)[1])
  wins[src] <- wins[src] + 1
}


# if the number ends in 2, it's a win for black
for (e in black_wins) {
  dst <- as.character(ends(chess_net, e)[2])
  wins[dst] <- wins[dst] + 1
}

# Calculate win ratio
win_ratios <- wins / (games_played + 0.001)  

detach("package:igraph", unload = TRUE)
```

```{r}
hist(win_ratios, breaks = 20)
```



```{r}
# Step 2: Create network object with win ratio as node attribute
set.vertex.attribute(chess_network_directed, "win_ratio", win_ratios)

# Step 3: Fit ERGM testing homophily on win ratio
model_homophily <- ergm(chess_network_directed ~ edges + 
                        absdiff("win_ratio"),
                        estimate = "MPLE")

# Step 4: View results
summary(model_homophily)
```

From the absdiff.winratio we observe that the estimate is -3.89. This indicates that that there is generally a small difference between the win ratio of two nodes. We can interpret this to mean that as the difference decreases, the probability of an edge existing between two nodes increases. So players with similar win ratios are more likely to be connected.


## Question 3, does a player's network centrality, predict their overall performance? 


```{r}
# players with high skills will be the ones with a larger win ratio
high_skill <- ifelse(win_ratios > 0.5, 1, 0)  # Define high skill based on win ratio
set.vertex.attribute(chess_network_directed, "high_skill", high_skill)


model_color_preference <- ergm(chess_network_directed ~ edges + 
                              nodeofactor("high_skill", base=1) +
                              nodeifactor("high_skill", base=1),
                              control = control.ergm(MCMLE.maxit = 30),
                              estimate = "MPLE")
```
```{r}
summary(model_color_preference)

# Use a faster GOF approach without full MCMC
model.gof <- gof(model_reciprocity ~ degree + distance,  # Simpler statistics
                 coef = coef(model_reciprocity),
                 estimate = "MPLE",  # Use MPLE instead of MCMC
                 control = control.gof.ergm(nsim = 10),  # Reduced simulations
                 verbose = TRUE)

# View summary of GOF statistics
summary(model.gof)

# Plot GOF results - only if needed and the plot fits in your output
par(mfrow = c(2, 2))  # 2x2 grid of plots
plot(model.gof)
```







